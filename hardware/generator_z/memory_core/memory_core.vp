//;    use POSIX;
//;    my $backtick = "`";
///////////////////////////////////////////////////////////////////
// CGRA memory generator
//////////////////////////////////////////////////////////////////


`$backtick`define xassert(condition, message) if(condition) begin $display(message); $finish(1); end


//; my $dwidth   = parameter(Name=>'dwidth', val=> 16, doc=>'word width');
//; my $ddepth   = parameter(Name=>'ddepth', val=> 1024, doc=>'number of words in the memory');

//; my $awidth = int(ceil(log($ddepth)/log(2)));

module `mname`(
clk,
reset,
config_addr,
config_data,
config_en,
data_in,
data_out,
wen_in,
ren_in,
valid_out,
chain_in,
chain_out,
chain_wen_in,
chain_valid_out,
almost_full,
almost_empty,
addr_in
);

input clk;
input reset;
input config_en;
input wen_in;
input ren_in;
input chain_wen_in;
input [31:0] config_addr;
input [31:0] config_data;
input [`$dwidth - 1`:0] data_in;
input [`$dwidth - 1`:0] chain_in;
input [`$dwidth - 1`:0] addr_in;

output chain_valid_out;
output [`$dwidth - 1`:0] chain_out;
output reg valid_out;
output reg almost_full;
output reg almost_empty;
output reg [`$dwidth - 1`:0] data_out;

wire  [2:0] mode;
wire  [2:0] tile_en;
wire [13:0] depth;
wire  [3:0] almost_count;
wire        enable_chain;

wire gclk;
wire wen_in_int;
wire mem_cen0;
wire mem_cen1;

wire lb_valid_out;
wire fifo_valid_out;
wire lb_almost_full;
wire fifo_almost_full;
wire lb_almost_empty;
wire fifo_almost_empty;
wire lb_wen;
wire lb_ren;
wire fifo_wen;
wire fifo_ren;

wire [`$dwidth - 1`:0] data_in_int;
wire [`$dwidth - 1`:0] mem_data_out0;
wire [`$dwidth - 1`:0] mem_data_out1;

wire [`$dwidth - 1`:0] lb_addr;
wire [`$dwidth - 1`:0] fifo_addr;
wire [`$dwidth*2 - 1`:0] lb_mem_data_out;
wire [`$dwidth*2 - 1`:0] fifo_mem_data_out;
wire [`$dwidth - 1`:0] lb_out;
wire [`$dwidth - 1`:0] fifo_out;

reg [`$dwidth - 1`:0] mem_data_in0;
reg [`$dwidth - 1`:0] mem_data_in1;
reg [31:0] config_mem;
reg [`$dwidth - 1`:0] mem_addr;
reg mem_ren0;
reg mem_wen0;
reg mem_ren1;
reg mem_wen1;
reg sram_sel;

assign mode = config_mem[1:0];
assign tile_en = config_mem[2];
assign depth = config_mem[15:3];
assign almost_count = config_mem[19:16];
assign enable_chain = config_mem[19];

assign gclk = clk & (tile_en==1'b1);

assign data_in_int = (enable_chain==1'b1)?chain_in:data_in;
assign wen_in_int = (enable_chain==1'b1)?chain_wen_in:wen_in;
assign chain_out = data_out;
assign chain_valid_out = valid_out;

always @(posedge clk or posedge reset) begin
  if (reset==1'b1) begin
    config_mem <= 32'd0;
  end else begin
    if (config_en==1'b1) begin
       case (config_addr[31:24])
//; for (my $j=0; $j<1; $j=$j+1) {
         8'd`$j`: config_mem[`($j+1)*32-1`:`$j*32`] <= config_data;
//; }
       endcase
    end
  end
end


always @(*) begin
  case (mode)
    2'd0: begin
      mem_wen0 <= lb_wen;
      mem_ren0 <= lb_ren;
      mem_wen1 <= lb_wen;
      mem_ren1 <= lb_ren;
      mem_addr <= lb_addr;
      {mem_data_in1,mem_data_in0} <= lb_mem_data_out;
      data_out <= lb_out; 
      valid_out <= lb_valid_out;
      almost_full <= lb_almost_full;
      almost_empty <= lb_almost_empty;
    end
    2'd1: begin
      mem_wen0 <= fifo_wen;
      mem_ren0 <= fifo_ren;
      mem_wen1 <= fifo_wen;
      mem_ren1 <= fifo_ren;
      mem_addr <= fifo_addr;
      {mem_data_in1,mem_data_in0} <= fifo_mem_data_out;
      data_out <= fifo_out;
      valid_out <= fifo_valid_out;
      almost_full <= fifo_almost_full;
      almost_empty <= fifo_almost_empty;
    end
    2'd2: begin
      mem_wen0 <= ~addr_in[`$awidth - 1`];
      mem_ren0 <= 1'b1;
      mem_wen1 <= addr_in[`$awidth - 1`];
      mem_ren1 <= 1'b1;
      mem_addr <= addr_in;      
      mem_data_in0 <= data_in;
      mem_data_in1 <= data_in;
      data_out <= (sram_sel==1'b1)?mem_data_in1:mem_data_in0;
      valid_out <= 1'b1;  
      almost_full <= 1'b0; 
      almost_empty <= 1'b0; 
    end
    default: begin
      mem_wen0 <= 1'b0; 
      mem_ren0 <= 1'b0;
      mem_wen1 <= 1'b0; 
      mem_ren1 <= 1'b1;
      mem_addr <= `$dwidth`'d0;      
      mem_data_in0 <= `$dwidth`'d0;
      mem_data_in1 <= `$dwidth`'d0;
      data_out <= `$dwidth`'d0;
      valid_out <= 1'b0;
      almost_full <= 1'b0;
      almost_empty <= 1'b0;
    end
  endcase
end

always @(posedge clk) begin
  sram_sel <= addr_in[`$awidth - 1`];
end

assign mem_cen0 = mem_wen0 | mem_ren0;
assign mem_cen1 = mem_wen1 | mem_ren1;

//; my $lb = generate('linebuffer_control', 'linebuffer_control', dwidth => $dwidth, ddepth => $ddepth );
//; my $fifo = generate('fifo_control', 'fifo_control', dwidth => $dwidth, ddepth => $ddepth );

`$lb->instantiate()`
(
.clk(gclk),
.reset(reset),
.data_in(data_in_int),
.wen(wen_in_int),
.data_out(lb_out),
.stall_read(ren_in),
.valid(lb_valid_out),
.almost_full(lb_almost_full),
.almost_empty(lb_almost_empty),
.almost_count(almost_count),
.depth(depth),
.addr_to_mem(lb_addr),
.data_to_mem(lb_mem_data_out),
.data_from_mem({mem_data_out1,mem_data_out0}),
.wen_to_mem(lb_wen),
.ren_to_mem(lb_ren)
);

`$fifo->instantiate()`
(
.clk(gclk),
.reset(reset),
.data_in(data_in_int),
.wen(wen_in_int),
.data_out(fifo_out),
.stall_read(ren_in),
.valid(fifo_valid_out),
.almost_full(fifo_almost_full),
.almost_empty(fifo_almost_empty),
.almost_count(almost_count),
.depth(depth),
.addr_to_mem(fifo_addr),
.data_to_mem(fifo_mem_data_out),
.data_from_mem({mem_data_out1,mem_data_out0}),
.wen_to_mem(fifo_wen),
.ren_to_mem(fifo_ren)
);

//; my $mem = generate('mem', 'mem', dwidth => $dwidth, awidth => ($awidth-1) );
//; my $mem_obj = clone($mem, 'mem_inst0');
`$mem_obj->instantiate()`
(
.data_out(mem_data_out0),
.data_in(mem_data_in0),
.clk(gclk),
.cen(mem_cen0),
.wen(mem_wen0),
.addr(mem_addr[`$awidth - 2`:0])
);

//; my $mem_obj = clone($mem, 'mem_inst1');
`$mem_obj->instantiate()`
(
.data_out(mem_data_out1),
.data_in(mem_data_in1),
.clk(gclk),
.cen(mem_cen1),
.wen(mem_wen1),
.addr(mem_addr[`$awidth - 2`:0])
);
endmodule

//;my $filename = "MEM".$self->mname();
//;open(MEMINFO, ">$filename") or die "Couldn't open file $filename, $!";
//;print MEMINFO "       <mode bith='1' bitl='0'>00</mode>\n";
//;print MEMINFO "       <tile_en bith='2' bitl='2'>0</tile_en>\n";
//;print MEMINFO "       <depth bith='15' bitl='3'>0</depth>\n";
//;print MEMINFO "       <almost_count bith='19' bitl='16'>0</almost_count>\n";
//;print MEMINFO "       <chain_enable bith='20' bitl='20'>0</chain_enable>\n";
//; close MEMINFO;

