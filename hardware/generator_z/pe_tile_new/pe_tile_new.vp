///////////////////////////////////////////////////////////////////
// CGRA PE generator 
//
// (C) Stanford University
// Please do not remove this header
//////////////////////////////////////////////////////////////////
//; use POSIX;
//; #global
//; my $bus_config = parameter(Name=>'bus_config', val=> "BUS16:16b#4_2:2_4:1_16:1_8:1_4 BUS1:1b#4_2:2_4:1_16:1_8:1_4", doc=>'buses used at global level.');
//; my $all_segments_for_all_tiles =  parameter(Name=>'all_segments_for_all_tiles', val=> "1", doc=>'stagger or overlap segments');
//; # for sb
//; my $sides = parameter(Name=>'sides', val=> 4, doc=>'number of edges for a SB'); 
//; my $feedthrough_outputs = parameter(Name=>'feedthrough_outputs', val=> "11000", doc=>'binary vector for feedthrough output config. Affects all sides. MSB corresponds to output 0 eg: 00000010 means output 7 is feedthrough. Length in bits = num_tracks.');
//; my $registered_outputs = parameter(Name=>'registered_outputs', val=> "00110", doc=>'binary vector for registered output config. Affects all sides. MSB corresponds to output 0. Registering feedthrough outputs is ignored.');
//; my $is_bidi = parameter(Name=>'is_bidi', val=> 0, doc=>'1 if SB pins are bidi. TBD.');
//; my $sb_fs = parameter(Name=>'sb_fs', val=> "10000#10000#10000", doc=>'binary vector for modifying fanin of sb muxes');

//; # for cb
//; my $cb_connections = parameter(Name=>'cb_connections', val=> "1111111111", doc=>'binary vector for specifying tracks that are muxed. MSB corresponds to track 0 eg: 1011 means tracks 0, 2, 3 are muxed to produce output for PE. Length in bits = num_tracks.');
//; my $has_constant = parameter(Name=>'has_constant', val=> 1, doc=>'set to 1 if the CB has a register to supply a constant '); 

//; # for pe
//; my $reg_inputs = parameter(Name=>'reg_inputs', val=> 1, List=>[1, 0], doc=>'Add register on the inputs');
//; my $reg_out    = parameter(Name=>'reg_out', val=> 1, List=>[1, 0], doc=>'Add register on the outputs');
//; my $use_add    = parameter(Name=>'use_add', val=> 2, List=>[2, 1, 0], doc=>'0 - no adders, 1 - simple ADDs, 2 - SAD');
//; my $use_cntr   = parameter(Name=>'use_cntr', val=> 1, List=>[1, 0],  doc=>'0 - no counter mode, 1 - enable counter mode');
//; my $use_bool   = parameter(Name=>'use_bool', Val=> 1, List=>[1, 0], Doc=>"0 - no booleans, 1 - simple gates");
//; my $use_shift  = parameter(Name=>'use_shift', val=> 1, List=>[1, 0], doc=>'Use shift operations');
//; my $mult_mode  = parameter(Name=>'mult_mode', val=> 2, List=>[2, 1, 0], doc=>'Use MAD(2) or MULT(1) or None(0)');
//; my $use_div    = parameter(Name=>'use_div', val=> 0, List=>[1, 0],  doc=>'0 - no divide, 1 - enable iterrative divide');
//; my $is_msb     = parameter(Name=>'is_msb', val=> 0, List=>[1, 0], doc=>'1 - MSB in 32b mode, 0 - LSB result');
//; my $en_double  = parameter(Name=>'en_double', val=> 0, List=>[1, 0], doc=>'1 - 32b supported, 0 - No 32b support');
//; my $lut_inps   = parameter(Name=>'lut_inps',
//;                               Val=>3, Min=>0, Step=>1, Max=>16,
//;                               Doc=>"0 - no LUT, 1-16 - uses LUTs with that number of inputs");
//;
//; my $intra_tile_addr = 0;

//; my $use_sad  = $use_add > 1;
//; my $use_lut  = ($lut_inps > 1);
//; my $use_c_input = ($use_sad > 0 || $mult_mode > 1 || $lut_inps > 3);
//; my $use_cntr = ($use_add > 1) ? 1 : 0;


//; #####################################################
//; #Populate bus track hash
//; #####################################################
//; my %bus_width_hash = ();
//; my %bus_segment_hash = ();
//; my %bus_registered_outputs_hash = ();
//; my %bus_num_tracks_hash = ();
//; my $wide_bus_width = 0;
//; foreach my $bus (split(' ', $bus_config)) {
//;   my $track_count=0;
//;   if ($bus=~m/(BUS\S+):(\S+)b#(\S+)/) {
//;     my $bus_name = $1;
//;     $bus_width_hash{ $bus_name } = $2;
//;     $bus_segment_hash{ $bus_name } = $3;
//;     if ($wide_bus_width < $bus_width_hash{ $bus_name }) {
//;       $wide_bus_width = $bus_width_hash{ $bus_name };
//;     }
//;     foreach my $seg_info (split(':',$bus_segment_hash{ $bus_name })) {
//;       $seg_info =~ m/(\S+)_(\S+)/;
//;       my $segment_length = $1;
//;       if ($all_segments_for_all_tiles==1) {
//;         $track_count += $segment_length;
//;       } else {
//;         $track_count += 1;
//;       }
//;     }
//;     $bus_num_tracks_hash{ $bus_name } = $track_count;
//;   }
//; }
//; my $filename = "TILE".$self->mname();
//; open(TILEINFO, ">$filename") or die "Couldn't open file $filename, $!";
//; my $tile_info_hash;
//; my $rename_hash;
module `mname` (
clk,
config_addr,
config_data,
//;   for my $bus (keys %bus_width_hash) {
//;     my $num_tracks = $bus_num_tracks_hash { $bus };
//;     for(my $i=0; $i<$sides; $i++) {
//;       for(my $j=0; $j<$num_tracks; $j++) {
out_`$bus`_S`$i`_T`$j`,
in_`$bus`_S`$i`_T`$j`,
//;      }
//;     }
//;   }
reset,
tile_id
);
//; my $config_bits_used = 0;
  input clk;
  input [31:0] config_addr;
  input [31:0] config_data;

//;   for my $bus (keys %bus_num_tracks_hash) {
//;     my $num_tracks = $bus_num_tracks_hash { $bus };
//;     my $bus_width = $bus_width_hash { $bus };
//;     for(my $i=0; $i<$sides; $i++) {
//;       for(my $j=0; $j<$num_tracks; $j++) {
  output [`$bus_width-1`:0] out_`$bus`_S`$i`_T`$j`;
  input [`$bus_width-1`:0] in_`$bus`_S`$i`_T`$j`;
//;      }
//;     }
//;   }

  input [15:0] tile_id;
  input reset;

//; #############################################################
//; # Generate PE enables
//; #############################################################

//; if($use_lut || $reg_inputs) {
   reg config_en_pe;
   always @(*) begin
     if (reset) begin
        config_en_pe = 1'b0;
     end else begin
        if ((config_addr[15:0]==tile_id)&&(config_addr[23:16]==8'd`$intra_tile_addr`)) begin
          config_en_pe = 1'b1;
        end else begin
          config_en_pe = 1'b0;
        end
     end
   end
//; }
//; $tile_info_hash->{ 'pe' } = {
//;   address => $intra_tile_addr
//; };

//;$intra_tile_addr+=1;

  // Note: verilator complains because some bits (opcode[31:16]) go unused...
  // For now, I will fix it with a verilator directive
  // FIXME owner please verify that unused bits are correct behavior and
  // FIXME maybe add a comment to that effect...?

  /* verilator lint_off UNUSED */
  reg [31:0] opcode;
  /* verilator lint_on UNUSED */

  always @(posedge clk) begin
    if (reset) begin
       opcode <= 32'd0;
    end else begin
       if ((config_addr[15:0]==tile_id)&&(config_addr[23:16]==8'd`$intra_tile_addr`)) begin
         opcode <= config_data;
       end
    end
  end
//; $tile_info_hash->{ 'opcode' } = {
//;   address => $intra_tile_addr
//; };
//; #############################################################
//; # Generate CBs and corresponding config enables
//; #############################################################
//; my @pe_inputs = ("BUS16#data0","BUS16#data1","BUS1#bit0","BUS1#bit1","BUS1#bit2");
//; if ($en_double & $use_shift) {
//;   push @pe_inputs, "BUS16#op_a_shift";
//; }
//; if ($use_c_input) {
//;   push @pe_inputs, "BUS16#data2";
//; }
//; if($en_double & $use_add > 0) {
//;   if($is_msb) {
//;     push @pe_inputs, "BUS16#carry_in";
//;     push @pe_inputs, "BUS1#cmpr_eq_in";
//;   } else {
//;     push @pe_inputs, "BUS1#res_p_msb";
//;   }
//; }
//; if($use_div) {
//;   if($is_msb) {
//;     push @pe_inputs,  "BUS16#div_low_msb";
//;   } elsif(!$en_double) {
//;     push @pe_inputs,  "BUS1#res_p_msb";
//;   }
//;   push @pe_inputs,  "BUS16#div_ci";
//; }
//; my $cb_wide = generate('cb', 'cbwide_base', width=>$wide_bus_width, num_tracks=>$bus_num_tracks_hash{'BUS16'}, has_constant=>$has_constant, feedthrough_outputs=>$cb_connections);
//; my $cb_1b = generate('cb', 'cb1b_base', width=>1, num_tracks=>$bus_num_tracks_hash{'BUS1'}, has_constant=>$has_constant, feedthrough_outputs=>$cb_connections);
//; my $num_tracks_wide = $bus_num_tracks_hash{'BUS16'};
//; my $num_tracks_1b = $bus_num_tracks_hash{'BUS1'};
//; my @cb_connections_arr = split('',$cb_connections);
//; my $input_count=0;
//; my $num_tracks;
//; my $cb;
//;
//; #######
//;
//;foreach my $pe_input (@pe_inputs) {
//; ##
//; ## Generate config enables for the input CB
//; ##
//; $intra_tile_addr+=1;
//; $pe_input =~ m/(\S*)#(\S*)/;
//; my $pe_input_bus = $1;
//; my $pe_input_name = $2;
  reg config_en_cb_`$pe_input_name`;
  always @(*) begin
    if (reset) begin
       config_en_cb_`$pe_input_name` = 1'b0;
    end else begin
       if ((config_addr[15:0]==tile_id)&&(config_addr[23:16]==8'd`$intra_tile_addr`)) begin
         config_en_cb_`$pe_input_name` = 1'b1;
       end else begin
         config_en_cb_`$pe_input_name` = 1'b0;
       end
    end
  end
//; $tile_info_hash->{ 'cb_'.$pe_input_name } = {
//;   address => $intra_tile_addr
//; };
//; ##
//; ## Instantiate the CB
//; ##
//; my $xside; 
//; if ($input_count % 2 == 0) {
//;  $xside = 2;
//; } else {
//;  $xside = 1;
//; }
//; if ($pe_input_bus eq "BUS16") {
//;   $cb = clone($cb_wide,'cb_'.$pe_input_name);
//;    $num_tracks=$num_tracks_wide;
//; } else {
//;   $cb = clone($cb_1b,'cb_'.$pe_input_name);
//;   $num_tracks=$num_tracks_1b;
//; }
//; if ($pe_input_bus eq "BUS16") {
  wire [15:0] `$pe_input_name`;
//;   } else {
  wire `$pe_input_name`;
//;   }
  `$cb->instantiate()`
  (
    .clk(clk),
    .reset(reset),
    .out(`$pe_input_name`),
//; my $k=0;
//;   for(my $j=0; $j<$num_tracks*2; $j++, $k++) {
//;     my $dirn;
//;     my $track = $k % $num_tracks;
//;     if ($j < $num_tracks) {
//;       $dirn="in";
//;     } else {
//;       $dirn="out";
//;     }
//;     if (@cb_connections_arr[$j]==1) {
//;       if ($pe_input_bus eq "BUS16") {
    .in_`$k`(`${dirn}`_BUS16_S`${xside}`_T`${track}`),
//;         $rename_hash->{ 'cb_'.$pe_input_name }{"in_${k}"} = "${dirn}_BUS16_S${xside}_T${track}";
//;       } else {
    .in_`$k`(`${dirn}`_BUS1_S`${xside}`_T`${track}`),
//;         $rename_hash->{ 'cb_'.$pe_input_name }{"in_${k}"} = "${dirn}_BUS1_S${xside}_T${track}";
//;       }
//;     }
//;   }    
    .config_addr(config_addr),
    .config_data(config_data),
    .config_en(config_en_cb_`$pe_input_name`)
  );
//; $tile_info_hash->{ 'cb_'.$pe_input_name }{'bus'} = $pe_input_bus;
//; $tile_info_hash->{ 'cb_'.$pe_input_name }{'mname'} = $cb->mname();
//; $rename_hash->{ 'cb_'.$pe_input_name }{'out'} = $pe_input_name;
//; $input_count = $input_count+1;
//; };

//; #############################################################
//; # Generate SB and corresponding config enables
//; #############################################################
//; ##
//; ## wide SB
//; ##
//;$intra_tile_addr+=1;
  reg config_en_sb_wide;
  always @(*) begin
    if (reset) begin
       config_en_sb_wide = 1'b0;
    end else begin
       if ((config_addr[15:0]==tile_id)&&(config_addr[23:16]==8'd`$intra_tile_addr`)) begin
         config_en_sb_wide = 1'b1;
       end else begin
         config_en_sb_wide = 1'b0;
       end
    end
  end
//; $tile_info_hash->{ 'sb_wide' } = {
//;   address => $intra_tile_addr
//; };
//; $feedthrough_outputs =~ m/BUS16:(\S+)/;
//; my $bus_feedthrough_outputs = $1;
//; $registered_outputs =~ m/BUS16:(\S+)/;
//; my $bus_registered_outputs = $1;
//;
//; my @wide_outputs = ("res");
//; if($en_double & $mult_mode > 0) {
//;   push @wide_outputs, "mult_res";
//; }
//; if($use_div) {
//;   push @wide_outputs, "div_co";
//; }
//; if($en_double & $use_add > 0) {
//;   if($is_msb) {
//;   } else {
//;      push @wide_outputs, "carry_out";
//;   }
//; }
//;  foreach my $pe_output (@wide_outputs) {
//;    if ($pe_output eq "mult_res") {
  wire [`2*$wide_bus_width-1`:0] pe_out_`$pe_output`;
//;    } else {
  wire [`$wide_bus_width-1`:0] pe_out_`$pe_output`;
//;    }
//;  }
//;   my $output_count = 0;
//;   my $sb_wide = generate('sb', 'sb_wide', width => $wide_bus_width, num_tracks => $bus_num_tracks_hash{'BUS16'}, sides => $sides, feedthrough_outputs=>$bus_feedthrough_outputs, registered_outputs=>$bus_registered_outputs, pe_output_count=>(scalar @wide_outputs), is_bidi=>$is_bidi, sb_fs=>$sb_fs);
  `$sb_wide->instantiate()`
  (
    .clk(clk),
    .reset(reset),
//;  foreach my $pe_output (@wide_outputs) {
    .pe_output_`$output_count`(pe_out_`$pe_output`),
//;    $rename_hash->{ 'sb_wide' }{'pe_output_'.$output_count} = "pe_out_".$pe_output;
//;    $output_count = $output_count + 1;
//;  }
//; for(my $i=0; $i<$sides; $i++) {
//;  for(my $j=0; $j<$bus_num_tracks_hash{'BUS16'}; $j++) {
    .out_`$i`_`$j`(out_BUS16_S`$i`_T`$j`),
    .in_`$i`_`$j`(in_BUS16_S`$i`_T`$j`),
//;    $rename_hash->{ 'sb_wide' }{"out_${i}_${j}"} = "out_BUS16_S${i}_T${j}";
//;    $rename_hash->{ 'sb_wide' }{"in_${i}_${j}"} = "in_BUS16_S${i}_T${j}";
//;  }
//; }
    .config_addr(config_addr),
    .config_data(config_data),
    .config_en(config_en_sb_wide)
  );
//; $tile_info_hash->{ 'sb_wide' }{'bus'} = 'BUS16';
//; $tile_info_hash->{ 'sb_wide' }{'mname'} = $sb_wide->mname();


//; ##
//; ## 1-bit SB
//; ##
//; 
//; $feedthrough_outputs =~ m/BUS1:(\S+)/;
//; my $bus_feedthrough_outputs = $1;
//; $registered_outputs =~ m/BUS1:(\S+)/;
//; my $bus_registered_outputs = $1;
//;  $intra_tile_addr+=1;
  reg config_en_sb_1bit;
  always @(*) begin
    if (reset) begin
       config_en_sb_1bit = 1'b0;
    end else begin
       if ((config_addr[15:0]==tile_id)&&(config_addr[23:16]==8'd`$intra_tile_addr`)) begin
         config_en_sb_1bit = 1'b1;
       end else begin
         config_en_sb_1bit = 1'b0;
       end
    end
  end
//; $tile_info_hash->{ 'sb_1bit' } = {
//;   address => $intra_tile_addr
//; };
//;
//; my @bit1_outputs = ("res_p");
//; if($en_double & $use_add > 0) {
//;   if($is_msb) {
//;   } else {
//;   push @bit1_outputs, "cmpr_eq_out";
//;   }
//; }
//;  foreach my $pe_output (@bit1_outputs) {
  wire pe_out_`$pe_output`;
//;  }
//;   my $output_count = 0;
//;   my $sb_1b = generate('sb', 'sb_1b', width => 1, num_tracks => $bus_num_tracks_hash{'BUS1'}, sides => $sides, feedthrough_outputs=>$bus_feedthrough_outputs, registered_outputs=>$bus_registered_outputs, pe_output_count=>(scalar @bit1_outputs), is_bidi=>$is_bidi, sb_fs=>$sb_fs);
  `$sb_1b->instantiate()`
  (
    .clk(clk),
    .reset(reset),
//;  foreach my $pe_output (@bit1_outputs) {
    .pe_output_`$output_count`(pe_out_`$pe_output`),
//;    $rename_hash->{ 'sb_1bit' }{'pe_output_'.$output_count} = "pe_out_".$pe_output;
//;    $output_count = $output_count + 1;
//;  }
//; for(my $i=0; $i<$sides; $i++) {
//;  for(my $j=0; $j<$bus_num_tracks_hash{'BUS1'}; $j++) {
    .out_`$i`_`$j`(out_BUS1_S`$i`_T`$j`),
    .in_`$i`_`$j`(in_BUS1_S`$i`_T`$j`),
//;    $rename_hash->{ 'sb_1bit' }{"out_${i}_${j}"} = "out_BUS1_S${i}_T${j}";
//;    $rename_hash->{ 'sb_1bit' }{"in_${i}_${j}"} = "in_BUS1_S${i}_T${j}";
//;  }
//; }
    .config_addr(config_addr),
    .config_data(config_data),
    .config_en(config_en_sb_1bit)
  );
//; $tile_info_hash->{ 'sb_1bit' }{'bus'} = 'BUS1';
//; $tile_info_hash->{ 'sb_1bit' }{'mname'} = $sb_1b->mname();

//; #############################################################
//; # Generate PE
//; #############################################################

//;my $pe = generate('test_pe', 'test_pe', reg_inputs => $reg_inputs, 
//;                   reg_out => $reg_out, use_add => $use_add,
//;                   use_cntr => $use_cntr, use_bool => $use_bool, use_shift => $use_shift,
//;                   mult_mode => $mult_mode, use_div => $use_div, is_msb => $is_msb,
//;                   en_double => $en_double, lut_inps => $lut_inps);

`$pe->instantiate()`
 (
//;if($use_lut || $reg_inputs || $reg_out) {
  .clk(clk),
  .rst_n(~reset),
  .clk_en(1'b1),
//;}
//; if($use_lut || $reg_inputs) {
  .cfg_d(config_data[31:0]),
  .cfg_a(config_addr[31:24]),
  .cfg_en(config_en_pe),
//;} else {
  .op_code(opcode[15:0]),
  // Note: verilator complains because opcode[31:16] goes unused...
  // For now, I will try to fix it with a verilator directive (/* verilator lint_off UNUSED */)
  // FIXME owner please verify that you mean for these bits to go unused and
  // FIXME maybe add a comment to that effect...?
//;}
//; foreach my $port (@pe_inputs) {
//;    $port =~ m/\S+#(\S*)/;
  .`$1`(`$1`),
//; }
//; foreach my $port (@wide_outputs) {
  .`$port`(pe_out_`$port`),
//; }
//; my $count=0;
   .irq(), // Assumes en_debug=1 in PE
//; foreach my $port (@bit1_outputs) {
//;   $count = $count + 1;
//;   if ($count==(scalar @bit1_outputs)) {
  .`$port`(pe_out_`$port`)
//;  } else {
  .`$port`(pe_out_`$port`),
//;  }
//; }
);
//; $tile_info_hash->{ 'pe' }{'reg_inputs'} = $reg_inputs;
//; $tile_info_hash->{ 'pe' }{'reg_out'} = $reg_out;   
//; $tile_info_hash->{ 'pe' }{'use_add'} = $use_add;  
//; $tile_info_hash->{ 'pe' }{'use_cntr'} = $use_cntr; 
//; $tile_info_hash->{ 'pe' }{'use_bool'} = $use_bool; 
//; $tile_info_hash->{ 'pe' }{'use_shift'} = $use_shift;
//; $tile_info_hash->{ 'pe' }{'mult_mode'} = $mult_mode;
//; $tile_info_hash->{ 'pe' }{'use_div'} = $use_div;  
//; $tile_info_hash->{ 'pe' }{'is_msb'} = $is_msb;   
//; $tile_info_hash->{ 'pe' }{'en_double'} = $en_double;
//; $tile_info_hash->{ 'pe' }{'lut_inps'} = $lut_inps;
//;
//;
//;
//;
//;
//;
//;
//;
//;
//;
//;
//;
//;
//;
//;#######################################################################
//;## Generate tile connectivity, and pe info 
//;##
//;#######################################################################
//;foreach my $feature (sort keys %$tile_info_hash)  {
//;  my $value = $tile_info_hash->{$feature};
//;################### PEs
//;  if ($feature=~m/pe/) {
//;    print TILEINFO "    <pe feature_address='$value->{'address'}'>\n";
//;    foreach my $param_name (sort keys %$value) {
//;      my $param_value = $value->{$param_name};
//;      if ($param_name!~m/address/) {
//;        print TILEINFO "        <$param_name> $param_value </$param_name>\n";
//;      }
//;    }
//;    print TILEINFO "    </pe>\n"
//;  }
//;################### OPCODEs
//;  if ($feature=~m/opcode/) {
//;    print TILEINFO "    <opcode feature_address='$value->{'address'}'></opcode>\n";
//;  }
//;################### CBs
//;  if ($feature=~m/cb/) {
//;    print TILEINFO "    <cb feature_address='$value->{'address'}' bus='$value->{'bus'}'>\n";
//;    my $filename = "CB".$value->{'mname'};
//;    open (INP, "<$filename") or die "Couldn't open file $filename, $!";
//;    while (<INP>) {
//;      my $line = $_;
//;      # while ( my ($find, $replace) = each(%$rename_hash->{$feature}) ) { # ref use DEPRECATED
//;      while ( my ($find, $replace) = each($rename_hash->{$feature}) ) {
//;#         print TILEINFO "$find###$replace###$line\n";
//;         $line=~s/>$find</>$replace</g;
//;         $line=~s/='$find'>/='$replace'>/g;
//;      }
//;      print TILEINFO $line;
//;    }
//;    close INP;
//;    print TILEINFO "    </cb>\n"
//;  }
//;################### SBs
//;  if ($feature=~m/sb/) {
//;    print TILEINFO "    <sb feature_address='$value->{'address'}' bus='$value->{'bus'}'>\n";
//;    my $filename = "SB".$value->{'mname'};
//;    open (INP, "<$filename") or die "Couldn't open file $filename, $!";
//;    while (<INP>) {
//;      my $line = $_;
//;      # while ( my ($find, $replace) = each(%$rename_hash->{$feature}) ) { # ref use DEPRECATED
//;      while ( my ($find, $replace) = each($rename_hash->{$feature}) ) {
//;#         print TILEINFO "$find###$replace###$line\n";
//;         $line=~s/>$find</>$replace</g;
//;         $line=~s/'$find'/'$replace'/g;
//;      }
//;      print TILEINFO $line;
//;    }
//;    close INP;
//;    print TILEINFO "    </sb>\n"
//;  }
//;}
//;close TILEINFO;
endmodule
